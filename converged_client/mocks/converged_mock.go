// Code generated by MockGen. DO NOT EDIT.
// Source: converged_client/converged.go
//
// Generated by this command:
//
//	mockgen -source=converged_client/converged.go -destination=converged_client/mocks/converged_mock.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	convergedclient "github.com/nutanix-cloud-native/prism-go-client/converged_client"
	gomock "go.uber.org/mock/gomock"
)

// MockGetter is a mock of Getter interface.
type MockGetter[T any] struct {
	ctrl     *gomock.Controller
	recorder *MockGetterMockRecorder[T]
	isgomock struct{}
}

// MockGetterMockRecorder is the mock recorder for MockGetter.
type MockGetterMockRecorder[T any] struct {
	mock *MockGetter[T]
}

// NewMockGetter creates a new mock instance.
func NewMockGetter[T any](ctrl *gomock.Controller) *MockGetter[T] {
	mock := &MockGetter[T]{ctrl: ctrl}
	mock.recorder = &MockGetterMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGetter[T]) EXPECT() *MockGetterMockRecorder[T] {
	return m.recorder
}

// Get mocks base method.
func (m *MockGetter[T]) Get(ctx context.Context, uuid string) (*T, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx, uuid)
	ret0, _ := ret[0].(*T)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockGetterMockRecorder[T]) Get(ctx, uuid any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockGetter[T])(nil).Get), ctx, uuid)
}

// MockLister is a mock of Lister interface.
type MockLister[T any] struct {
	ctrl     *gomock.Controller
	recorder *MockListerMockRecorder[T]
	isgomock struct{}
}

// MockListerMockRecorder is the mock recorder for MockLister.
type MockListerMockRecorder[T any] struct {
	mock *MockLister[T]
}

// NewMockLister creates a new mock instance.
func NewMockLister[T any](ctrl *gomock.Controller) *MockLister[T] {
	mock := &MockLister[T]{ctrl: ctrl}
	mock.recorder = &MockListerMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLister[T]) EXPECT() *MockListerMockRecorder[T] {
	return m.recorder
}

// List mocks base method.
func (m *MockLister[T]) List(ctx context.Context, opts ...convergedclient.ODataOption) ([]T, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "List", varargs...)
	ret0, _ := ret[0].([]T)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// List indicates an expected call of List.
func (mr *MockListerMockRecorder[T]) List(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*MockLister[T])(nil).List), varargs...)
}

// NewIterator mocks base method.
func (m *MockLister[T]) NewIterator(ctx context.Context, opts ...convergedclient.ODataOption) convergedclient.Iterator[T] {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "NewIterator", varargs...)
	ret0, _ := ret[0].(convergedclient.Iterator[T])
	return ret0
}

// NewIterator indicates an expected call of NewIterator.
func (mr *MockListerMockRecorder[T]) NewIterator(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewIterator", reflect.TypeOf((*MockLister[T])(nil).NewIterator), varargs...)
}

// MockCreator is a mock of Creator interface.
type MockCreator[T any] struct {
	ctrl     *gomock.Controller
	recorder *MockCreatorMockRecorder[T]
	isgomock struct{}
}

// MockCreatorMockRecorder is the mock recorder for MockCreator.
type MockCreatorMockRecorder[T any] struct {
	mock *MockCreator[T]
}

// NewMockCreator creates a new mock instance.
func NewMockCreator[T any](ctrl *gomock.Controller) *MockCreator[T] {
	mock := &MockCreator[T]{ctrl: ctrl}
	mock.recorder = &MockCreatorMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCreator[T]) EXPECT() *MockCreatorMockRecorder[T] {
	return m.recorder
}

// Create mocks base method.
func (m *MockCreator[T]) Create(ctx context.Context, entity *T) (*T, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Create", ctx, entity)
	ret0, _ := ret[0].(*T)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Create indicates an expected call of Create.
func (mr *MockCreatorMockRecorder[T]) Create(ctx, entity any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockCreator[T])(nil).Create), ctx, entity)
}

// MockAsyncCreator is a mock of AsyncCreator interface.
type MockAsyncCreator[T any] struct {
	ctrl     *gomock.Controller
	recorder *MockAsyncCreatorMockRecorder[T]
	isgomock struct{}
}

// MockAsyncCreatorMockRecorder is the mock recorder for MockAsyncCreator.
type MockAsyncCreatorMockRecorder[T any] struct {
	mock *MockAsyncCreator[T]
}

// NewMockAsyncCreator creates a new mock instance.
func NewMockAsyncCreator[T any](ctrl *gomock.Controller) *MockAsyncCreator[T] {
	mock := &MockAsyncCreator[T]{ctrl: ctrl}
	mock.recorder = &MockAsyncCreatorMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAsyncCreator[T]) EXPECT() *MockAsyncCreatorMockRecorder[T] {
	return m.recorder
}

// CreateAsync mocks base method.
func (m *MockAsyncCreator[T]) CreateAsync(ctx context.Context, entity *T) (convergedclient.Operation[T], error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateAsync", ctx, entity)
	ret0, _ := ret[0].(convergedclient.Operation[T])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateAsync indicates an expected call of CreateAsync.
func (mr *MockAsyncCreatorMockRecorder[T]) CreateAsync(ctx, entity any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateAsync", reflect.TypeOf((*MockAsyncCreator[T])(nil).CreateAsync), ctx, entity)
}

// MockUpdater is a mock of Updater interface.
type MockUpdater[T any] struct {
	ctrl     *gomock.Controller
	recorder *MockUpdaterMockRecorder[T]
	isgomock struct{}
}

// MockUpdaterMockRecorder is the mock recorder for MockUpdater.
type MockUpdaterMockRecorder[T any] struct {
	mock *MockUpdater[T]
}

// NewMockUpdater creates a new mock instance.
func NewMockUpdater[T any](ctrl *gomock.Controller) *MockUpdater[T] {
	mock := &MockUpdater[T]{ctrl: ctrl}
	mock.recorder = &MockUpdaterMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUpdater[T]) EXPECT() *MockUpdaterMockRecorder[T] {
	return m.recorder
}

// Update mocks base method.
func (m *MockUpdater[T]) Update(ctx context.Context, uuid string, entity *T) (*T, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Update", ctx, uuid, entity)
	ret0, _ := ret[0].(*T)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Update indicates an expected call of Update.
func (mr *MockUpdaterMockRecorder[T]) Update(ctx, uuid, entity any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockUpdater[T])(nil).Update), ctx, uuid, entity)
}

// MockAsyncUpdater is a mock of AsyncUpdater interface.
type MockAsyncUpdater[T any] struct {
	ctrl     *gomock.Controller
	recorder *MockAsyncUpdaterMockRecorder[T]
	isgomock struct{}
}

// MockAsyncUpdaterMockRecorder is the mock recorder for MockAsyncUpdater.
type MockAsyncUpdaterMockRecorder[T any] struct {
	mock *MockAsyncUpdater[T]
}

// NewMockAsyncUpdater creates a new mock instance.
func NewMockAsyncUpdater[T any](ctrl *gomock.Controller) *MockAsyncUpdater[T] {
	mock := &MockAsyncUpdater[T]{ctrl: ctrl}
	mock.recorder = &MockAsyncUpdaterMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAsyncUpdater[T]) EXPECT() *MockAsyncUpdaterMockRecorder[T] {
	return m.recorder
}

// UpdateAsync mocks base method.
func (m *MockAsyncUpdater[T]) UpdateAsync(ctx context.Context, uuid string, entity *T) (convergedclient.Operation[T], error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateAsync", ctx, uuid, entity)
	ret0, _ := ret[0].(convergedclient.Operation[T])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateAsync indicates an expected call of UpdateAsync.
func (mr *MockAsyncUpdaterMockRecorder[T]) UpdateAsync(ctx, uuid, entity any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateAsync", reflect.TypeOf((*MockAsyncUpdater[T])(nil).UpdateAsync), ctx, uuid, entity)
}

// MockDeleter is a mock of Deleter interface.
type MockDeleter[T any] struct {
	ctrl     *gomock.Controller
	recorder *MockDeleterMockRecorder[T]
	isgomock struct{}
}

// MockDeleterMockRecorder is the mock recorder for MockDeleter.
type MockDeleterMockRecorder[T any] struct {
	mock *MockDeleter[T]
}

// NewMockDeleter creates a new mock instance.
func NewMockDeleter[T any](ctrl *gomock.Controller) *MockDeleter[T] {
	mock := &MockDeleter[T]{ctrl: ctrl}
	mock.recorder = &MockDeleterMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDeleter[T]) EXPECT() *MockDeleterMockRecorder[T] {
	return m.recorder
}

// Delete mocks base method.
func (m *MockDeleter[T]) Delete(ctx context.Context, uuid string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", ctx, uuid)
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete.
func (mr *MockDeleterMockRecorder[T]) Delete(ctx, uuid any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockDeleter[T])(nil).Delete), ctx, uuid)
}

// MockAsyncDeleter is a mock of AsyncDeleter interface.
type MockAsyncDeleter[T any] struct {
	ctrl     *gomock.Controller
	recorder *MockAsyncDeleterMockRecorder[T]
	isgomock struct{}
}

// MockAsyncDeleterMockRecorder is the mock recorder for MockAsyncDeleter.
type MockAsyncDeleterMockRecorder[T any] struct {
	mock *MockAsyncDeleter[T]
}

// NewMockAsyncDeleter creates a new mock instance.
func NewMockAsyncDeleter[T any](ctrl *gomock.Controller) *MockAsyncDeleter[T] {
	mock := &MockAsyncDeleter[T]{ctrl: ctrl}
	mock.recorder = &MockAsyncDeleterMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAsyncDeleter[T]) EXPECT() *MockAsyncDeleterMockRecorder[T] {
	return m.recorder
}

// DeleteAsync mocks base method.
func (m *MockAsyncDeleter[T]) DeleteAsync(ctx context.Context, uuid string) (convergedclient.Operation[convergedclient.NoEntity], error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteAsync", ctx, uuid)
	ret0, _ := ret[0].(convergedclient.Operation[convergedclient.NoEntity])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteAsync indicates an expected call of DeleteAsync.
func (mr *MockAsyncDeleterMockRecorder[T]) DeleteAsync(ctx, uuid any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteAsync", reflect.TypeOf((*MockAsyncDeleter[T])(nil).DeleteAsync), ctx, uuid)
}

// MockODataOptions is a mock of ODataOptions interface.
type MockODataOptions struct {
	ctrl     *gomock.Controller
	recorder *MockODataOptionsMockRecorder
	isgomock struct{}
}

// MockODataOptionsMockRecorder is the mock recorder for MockODataOptions.
type MockODataOptionsMockRecorder struct {
	mock *MockODataOptions
}

// NewMockODataOptions creates a new mock instance.
func NewMockODataOptions(ctrl *gomock.Controller) *MockODataOptions {
	mock := &MockODataOptions{ctrl: ctrl}
	mock.recorder = &MockODataOptionsMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockODataOptions) EXPECT() *MockODataOptionsMockRecorder {
	return m.recorder
}

// SetApplyOption mocks base method.
func (m *MockODataOptions) SetApplyOption(apply string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetApplyOption", apply)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetApplyOption indicates an expected call of SetApplyOption.
func (mr *MockODataOptionsMockRecorder) SetApplyOption(apply any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetApplyOption", reflect.TypeOf((*MockODataOptions)(nil).SetApplyOption), apply)
}

// SetExpandOption mocks base method.
func (m *MockODataOptions) SetExpandOption(expand string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetExpandOption", expand)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetExpandOption indicates an expected call of SetExpandOption.
func (mr *MockODataOptionsMockRecorder) SetExpandOption(expand any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetExpandOption", reflect.TypeOf((*MockODataOptions)(nil).SetExpandOption), expand)
}

// SetFilterOption mocks base method.
func (m *MockODataOptions) SetFilterOption(filter string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetFilterOption", filter)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetFilterOption indicates an expected call of SetFilterOption.
func (mr *MockODataOptionsMockRecorder) SetFilterOption(filter any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetFilterOption", reflect.TypeOf((*MockODataOptions)(nil).SetFilterOption), filter)
}

// SetLimitOption mocks base method.
func (m *MockODataOptions) SetLimitOption(limit int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetLimitOption", limit)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetLimitOption indicates an expected call of SetLimitOption.
func (mr *MockODataOptionsMockRecorder) SetLimitOption(limit any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetLimitOption", reflect.TypeOf((*MockODataOptions)(nil).SetLimitOption), limit)
}

// SetOrderByOption mocks base method.
func (m *MockODataOptions) SetOrderByOption(orderBy string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetOrderByOption", orderBy)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetOrderByOption indicates an expected call of SetOrderByOption.
func (mr *MockODataOptionsMockRecorder) SetOrderByOption(orderBy any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetOrderByOption", reflect.TypeOf((*MockODataOptions)(nil).SetOrderByOption), orderBy)
}

// SetPageOption mocks base method.
func (m *MockODataOptions) SetPageOption(page int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetPageOption", page)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetPageOption indicates an expected call of SetPageOption.
func (mr *MockODataOptionsMockRecorder) SetPageOption(page any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetPageOption", reflect.TypeOf((*MockODataOptions)(nil).SetPageOption), page)
}

// SetSelectOption mocks base method.
func (m *MockODataOptions) SetSelectOption(selectFields string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetSelectOption", selectFields)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetSelectOption indicates an expected call of SetSelectOption.
func (mr *MockODataOptionsMockRecorder) SetSelectOption(selectFields any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetSelectOption", reflect.TypeOf((*MockODataOptions)(nil).SetSelectOption), selectFields)
}

// MockOperation is a mock of Operation interface.
type MockOperation[T any] struct {
	ctrl     *gomock.Controller
	recorder *MockOperationMockRecorder[T]
	isgomock struct{}
}

// MockOperationMockRecorder is the mock recorder for MockOperation.
type MockOperationMockRecorder[T any] struct {
	mock *MockOperation[T]
}

// NewMockOperation creates a new mock instance.
func NewMockOperation[T any](ctrl *gomock.Controller) *MockOperation[T] {
	mock := &MockOperation[T]{ctrl: ctrl}
	mock.recorder = &MockOperationMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockOperation[T]) EXPECT() *MockOperationMockRecorder[T] {
	return m.recorder
}

// Errors mocks base method.
func (m *MockOperation[T]) Errors() []error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Errors")
	ret0, _ := ret[0].([]error)
	return ret0
}

// Errors indicates an expected call of Errors.
func (mr *MockOperationMockRecorder[T]) Errors() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Errors", reflect.TypeOf((*MockOperation[T])(nil).Errors))
}

// IsDone mocks base method.
func (m *MockOperation[T]) IsDone() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsDone")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsDone indicates an expected call of IsDone.
func (mr *MockOperationMockRecorder[T]) IsDone() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsDone", reflect.TypeOf((*MockOperation[T])(nil).IsDone))
}

// IsFailed mocks base method.
func (m *MockOperation[T]) IsFailed() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsFailed")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsFailed indicates an expected call of IsFailed.
func (mr *MockOperationMockRecorder[T]) IsFailed() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsFailed", reflect.TypeOf((*MockOperation[T])(nil).IsFailed))
}

// IsSuccess mocks base method.
func (m *MockOperation[T]) IsSuccess() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsSuccess")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsSuccess indicates an expected call of IsSuccess.
func (mr *MockOperationMockRecorder[T]) IsSuccess() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsSuccess", reflect.TypeOf((*MockOperation[T])(nil).IsSuccess))
}

// Results mocks base method.
func (m *MockOperation[T]) Results() ([]*T, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Results")
	ret0, _ := ret[0].([]*T)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Results indicates an expected call of Results.
func (mr *MockOperationMockRecorder[T]) Results() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Results", reflect.TypeOf((*MockOperation[T])(nil).Results))
}

// Status mocks base method.
func (m *MockOperation[T]) Status() convergedclient.TaskStatus {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Status")
	ret0, _ := ret[0].(convergedclient.TaskStatus)
	return ret0
}

// Status indicates an expected call of Status.
func (mr *MockOperationMockRecorder[T]) Status() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Status", reflect.TypeOf((*MockOperation[T])(nil).Status))
}

// UUID mocks base method.
func (m *MockOperation[T]) UUID() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UUID")
	ret0, _ := ret[0].(string)
	return ret0
}

// UUID indicates an expected call of UUID.
func (mr *MockOperationMockRecorder[T]) UUID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UUID", reflect.TypeOf((*MockOperation[T])(nil).UUID))
}

// Wait mocks base method.
func (m *MockOperation[T]) Wait(ctx context.Context) ([]*T, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Wait", ctx)
	ret0, _ := ret[0].([]*T)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Wait indicates an expected call of Wait.
func (mr *MockOperationMockRecorder[T]) Wait(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Wait", reflect.TypeOf((*MockOperation[T])(nil).Wait), ctx)
}

// MockNoEntity is a mock of NoEntity interface.
type MockNoEntity struct {
	ctrl     *gomock.Controller
	recorder *MockNoEntityMockRecorder
	isgomock struct{}
}

// MockNoEntityMockRecorder is the mock recorder for MockNoEntity.
type MockNoEntityMockRecorder struct {
	mock *MockNoEntity
}

// NewMockNoEntity creates a new mock instance.
func NewMockNoEntity(ctrl *gomock.Controller) *MockNoEntity {
	mock := &MockNoEntity{ctrl: ctrl}
	mock.recorder = &MockNoEntityMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockNoEntity) EXPECT() *MockNoEntityMockRecorder {
	return m.recorder
}
