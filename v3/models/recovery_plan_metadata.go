// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// RecoveryPlanMetadata recovery_plan metadata
//
// The recovery_plan kind metadata
//
// swagger:model recovery_plan_metadata
type RecoveryPlanMetadata struct {

	// Categories for the recovery_plan. This allows assigning one value
	// of a key to any entity. Changes done in this will be reflected in
	// the categories_mapping field.
	//
	Categories map[string]string `json:"categories,omitempty"`

	// Categories for the recovery_plan. This allows setting up multiple
	// values from a single key. Categories assigned using the older view will be
	// present here. This is the new way of assigning categories.
	//
	CategoriesMapping map[string][]string `json:"categories_mapping,omitempty"`

	// UTC date and time in RFC-3339 format when recovery_plan was created
	//
	// Read Only: true
	// Format: date-time
	CreationTime strfmt.DateTime `json:"creation_time,omitempty"`

	// Logical entity version that allows serializing updates to the entity
	// across multiple API namespaces.  For kinds that support
	// entity_version, it overrides spec_version described above.
	//
	// Read Only: true
	EntityVersion string `json:"entity_version,omitempty"`

	// The kind name
	// Required: true
	// Read Only: true
	Kind string `json:"kind"`

	// UTC date and time in RFC-3339 format when recovery_plan was last updated
	//
	// Read Only: true
	// Format: date-time
	LastUpdateTime strfmt.DateTime `json:"last_update_time,omitempty"`

	// recovery_plan name
	// Read Only: true
	// Max Length: 80
	Name string `json:"name,omitempty"`

	// owner reference
	OwnerReference *UserReference `json:"owner_reference,omitempty"`

	// The project the recovery_plan is in.
	ProjectReference *ProjectReference `json:"project_reference,omitempty"`

	// Applied on Prism Central only. Indicate whether force to translate the spec of the fanout request to fit the target cluster API schema.
	//
	ShouldForceTranslate bool `json:"should_force_translate,omitempty"`

	// Hash of the spec. This will be returned from server.
	//
	SpecHash string `json:"spec_hash,omitempty"`

	// Version number of the latest spec.
	SpecVersion int64 `json:"spec_version,omitempty"`

	// Client need to specify this field as true if user want to use the
	// newer way of assigning the categories. Without this things should work
	// as it was earlier.
	//
	UseCategoriesMapping *bool `json:"use_categories_mapping,omitempty"`

	// recovery_plan uuid
	// Pattern: ^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this recovery plan metadata
func (m *RecoveryPlanMetadata) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCreationTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKind(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastUpdateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOwnerReference(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProjectReference(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUUID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RecoveryPlanMetadata) validateCreationTime(formats strfmt.Registry) error {
	if swag.IsZero(m.CreationTime) { // not required
		return nil
	}

	if err := validate.FormatOf("creation_time", "body", "date-time", m.CreationTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *RecoveryPlanMetadata) validateKind(formats strfmt.Registry) error {

	if err := validate.RequiredString("kind", "body", m.Kind); err != nil {
		return err
	}

	return nil
}

func (m *RecoveryPlanMetadata) validateLastUpdateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.LastUpdateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("last_update_time", "body", "date-time", m.LastUpdateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *RecoveryPlanMetadata) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("name", "body", m.Name, 80); err != nil {
		return err
	}

	return nil
}

func (m *RecoveryPlanMetadata) validateOwnerReference(formats strfmt.Registry) error {
	if swag.IsZero(m.OwnerReference) { // not required
		return nil
	}

	if m.OwnerReference != nil {
		if err := m.OwnerReference.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("owner_reference")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("owner_reference")
			}
			return err
		}
	}

	return nil
}

func (m *RecoveryPlanMetadata) validateProjectReference(formats strfmt.Registry) error {
	if swag.IsZero(m.ProjectReference) { // not required
		return nil
	}

	if m.ProjectReference != nil {
		if err := m.ProjectReference.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("project_reference")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("project_reference")
			}
			return err
		}
	}

	return nil
}

func (m *RecoveryPlanMetadata) validateUUID(formats strfmt.Registry) error {
	if swag.IsZero(m.UUID) { // not required
		return nil
	}

	if err := validate.Pattern("uuid", "body", m.UUID, `^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$`); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this recovery plan metadata based on the context it is used
func (m *RecoveryPlanMetadata) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCreationTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEntityVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateKind(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLastUpdateTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOwnerReference(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProjectReference(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RecoveryPlanMetadata) contextValidateCreationTime(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "creation_time", "body", strfmt.DateTime(m.CreationTime)); err != nil {
		return err
	}

	return nil
}

func (m *RecoveryPlanMetadata) contextValidateEntityVersion(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "entity_version", "body", string(m.EntityVersion)); err != nil {
		return err
	}

	return nil
}

func (m *RecoveryPlanMetadata) contextValidateKind(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "kind", "body", string(m.Kind)); err != nil {
		return err
	}

	return nil
}

func (m *RecoveryPlanMetadata) contextValidateLastUpdateTime(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "last_update_time", "body", strfmt.DateTime(m.LastUpdateTime)); err != nil {
		return err
	}

	return nil
}

func (m *RecoveryPlanMetadata) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "name", "body", string(m.Name)); err != nil {
		return err
	}

	return nil
}

func (m *RecoveryPlanMetadata) contextValidateOwnerReference(ctx context.Context, formats strfmt.Registry) error {

	if m.OwnerReference != nil {

		if swag.IsZero(m.OwnerReference) { // not required
			return nil
		}

		if err := m.OwnerReference.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("owner_reference")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("owner_reference")
			}
			return err
		}
	}

	return nil
}

func (m *RecoveryPlanMetadata) contextValidateProjectReference(ctx context.Context, formats strfmt.Registry) error {

	if m.ProjectReference != nil {

		if swag.IsZero(m.ProjectReference) { // not required
			return nil
		}

		if err := m.ProjectReference.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("project_reference")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("project_reference")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RecoveryPlanMetadata) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RecoveryPlanMetadata) UnmarshalBinary(b []byte) error {
	var res RecoveryPlanMetadata
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
