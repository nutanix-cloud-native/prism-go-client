// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ClusterConfig Cluster Configuration
//
// Cluster Configuration.
//
// swagger:model cluster_config
type ClusterConfig struct {

	// List of valid ssh keys for the cluster.
	AuthorizedPublicKeyList []*PublicKey `json:"authorized_public_key_list"`

	// build
	// Read Only: true
	Build *BuildInfo `json:"build,omitempty"`

	// List of cluster trusted CA certificates.
	// Read Only: true
	CaCertificateList []*CaCert `json:"ca_certificate_list"`

	// certification signing info
	CertificationSigningInfo *CertificationSigningInfo `json:"certification_signing_info,omitempty"`

	// client auth
	ClientAuth *ClientAuth `json:"client_auth,omitempty"`

	// Cluster architecture.
	// Read Only: true
	ClusterArch string `json:"cluster_arch,omitempty"`

	// Domain awareness supported on cluster.
	DomainAwarenessLevel *string `json:"domain_awareness_level,omitempty"`

	// Indicates if downsampling of metrics syncing between PE
	// and PC is enabled or not.
	//
	EnableEfficientMetricSync bool `json:"enable_efficient_metric_sync,omitempty"`

	// Array of enabled features.
	EnabledFeatureList []string `json:"enabled_feature_list"`

	// encryption status
	EncryptionStatus *EncryptionStatus `json:"encryption_status,omitempty"`

	// External Connector Configurations.
	ExternalConfigurations *ExternalConfigurations `json:"external_configurations,omitempty"`

	// GPU driver version.
	GpuDriverVersion string `json:"gpu_driver_version,omitempty"`

	// Indicates if cluster is available to contact.
	// Read Only: true
	IsAvailable *bool `json:"is_available,omitempty"`

	// List of cluster management servers.
	// Read Only: true
	ManagementServerList []*ClusterManagementServer `json:"management_server_list"`

	// operation mode
	OperationMode ClusterOperationMode `json:"operation_mode,omitempty"`

	// Cluster supported redundancy factor.
	RedundancyFactor int32 `json:"redundancy_factor,omitempty"`

	// service list
	// Read Only: true
	ServiceList ClusterServiceList `json:"service_list,omitempty"`

	// Map of software on the cluster with software type as the
	// key.
	//
	SoftwareMap map[string]ClusterSoftware `json:"software_map,omitempty"`

	// ssl key
	// Read Only: true
	SslKey *SslKey `json:"ssl_key,omitempty"`

	// Verbosity level settings for populating support information.
	// - 'Nothing': Send nothing
	// - 'Basic': Send basic information - skip core dump and hypervisor
	//            stats information
	// - 'BasicPlusCoreDump': Send basic and core dump information
	// - 'All': Send all information
	//
	SupportedInformationVerbosity *string `json:"supported_information_verbosity,omitempty"`

	// Zone name used in value of TZ environment variable.
	Timezone string `json:"timezone,omitempty"`
}

// Validate validates this cluster config
func (m *ClusterConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAuthorizedPublicKeyList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBuild(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCaCertificateList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCertificationSigningInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClientAuth(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEncryptionStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExternalConfigurations(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateManagementServerList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOperationMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServiceList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSoftwareMap(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSslKey(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterConfig) validateAuthorizedPublicKeyList(formats strfmt.Registry) error {
	if swag.IsZero(m.AuthorizedPublicKeyList) { // not required
		return nil
	}

	for i := 0; i < len(m.AuthorizedPublicKeyList); i++ {
		if swag.IsZero(m.AuthorizedPublicKeyList[i]) { // not required
			continue
		}

		if m.AuthorizedPublicKeyList[i] != nil {
			if err := m.AuthorizedPublicKeyList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("authorized_public_key_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("authorized_public_key_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterConfig) validateBuild(formats strfmt.Registry) error {
	if swag.IsZero(m.Build) { // not required
		return nil
	}

	if m.Build != nil {
		if err := m.Build.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("build")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("build")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterConfig) validateCaCertificateList(formats strfmt.Registry) error {
	if swag.IsZero(m.CaCertificateList) { // not required
		return nil
	}

	for i := 0; i < len(m.CaCertificateList); i++ {
		if swag.IsZero(m.CaCertificateList[i]) { // not required
			continue
		}

		if m.CaCertificateList[i] != nil {
			if err := m.CaCertificateList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ca_certificate_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("ca_certificate_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterConfig) validateCertificationSigningInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.CertificationSigningInfo) { // not required
		return nil
	}

	if m.CertificationSigningInfo != nil {
		if err := m.CertificationSigningInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("certification_signing_info")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("certification_signing_info")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterConfig) validateClientAuth(formats strfmt.Registry) error {
	if swag.IsZero(m.ClientAuth) { // not required
		return nil
	}

	if m.ClientAuth != nil {
		if err := m.ClientAuth.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("client_auth")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("client_auth")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterConfig) validateEncryptionStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.EncryptionStatus) { // not required
		return nil
	}

	if m.EncryptionStatus != nil {
		if err := m.EncryptionStatus.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("encryption_status")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("encryption_status")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterConfig) validateExternalConfigurations(formats strfmt.Registry) error {
	if swag.IsZero(m.ExternalConfigurations) { // not required
		return nil
	}

	if m.ExternalConfigurations != nil {
		if err := m.ExternalConfigurations.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("external_configurations")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("external_configurations")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterConfig) validateManagementServerList(formats strfmt.Registry) error {
	if swag.IsZero(m.ManagementServerList) { // not required
		return nil
	}

	for i := 0; i < len(m.ManagementServerList); i++ {
		if swag.IsZero(m.ManagementServerList[i]) { // not required
			continue
		}

		if m.ManagementServerList[i] != nil {
			if err := m.ManagementServerList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("management_server_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("management_server_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterConfig) validateOperationMode(formats strfmt.Registry) error {
	if swag.IsZero(m.OperationMode) { // not required
		return nil
	}

	if err := m.OperationMode.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("operation_mode")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("operation_mode")
		}
		return err
	}

	return nil
}

func (m *ClusterConfig) validateServiceList(formats strfmt.Registry) error {
	if swag.IsZero(m.ServiceList) { // not required
		return nil
	}

	if err := m.ServiceList.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("service_list")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("service_list")
		}
		return err
	}

	return nil
}

func (m *ClusterConfig) validateSoftwareMap(formats strfmt.Registry) error {
	if swag.IsZero(m.SoftwareMap) { // not required
		return nil
	}

	for k := range m.SoftwareMap {

		if err := validate.Required("software_map"+"."+k, "body", m.SoftwareMap[k]); err != nil {
			return err
		}
		if val, ok := m.SoftwareMap[k]; ok {
			if err := val.Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("software_map" + "." + k)
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("software_map" + "." + k)
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterConfig) validateSslKey(formats strfmt.Registry) error {
	if swag.IsZero(m.SslKey) { // not required
		return nil
	}

	if m.SslKey != nil {
		if err := m.SslKey.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ssl_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ssl_key")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster config based on the context it is used
func (m *ClusterConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAuthorizedPublicKeyList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBuild(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCaCertificateList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCertificationSigningInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateClientAuth(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateClusterArch(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEncryptionStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExternalConfigurations(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsAvailable(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateManagementServerList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOperationMode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateServiceList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSoftwareMap(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSslKey(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterConfig) contextValidateAuthorizedPublicKeyList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AuthorizedPublicKeyList); i++ {

		if m.AuthorizedPublicKeyList[i] != nil {

			if swag.IsZero(m.AuthorizedPublicKeyList[i]) { // not required
				return nil
			}

			if err := m.AuthorizedPublicKeyList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("authorized_public_key_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("authorized_public_key_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterConfig) contextValidateBuild(ctx context.Context, formats strfmt.Registry) error {

	if m.Build != nil {

		if swag.IsZero(m.Build) { // not required
			return nil
		}

		if err := m.Build.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("build")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("build")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterConfig) contextValidateCaCertificateList(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "ca_certificate_list", "body", []*CaCert(m.CaCertificateList)); err != nil {
		return err
	}

	for i := 0; i < len(m.CaCertificateList); i++ {

		if m.CaCertificateList[i] != nil {

			if swag.IsZero(m.CaCertificateList[i]) { // not required
				return nil
			}

			if err := m.CaCertificateList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ca_certificate_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("ca_certificate_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterConfig) contextValidateCertificationSigningInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.CertificationSigningInfo != nil {

		if swag.IsZero(m.CertificationSigningInfo) { // not required
			return nil
		}

		if err := m.CertificationSigningInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("certification_signing_info")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("certification_signing_info")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterConfig) contextValidateClientAuth(ctx context.Context, formats strfmt.Registry) error {

	if m.ClientAuth != nil {

		if swag.IsZero(m.ClientAuth) { // not required
			return nil
		}

		if err := m.ClientAuth.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("client_auth")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("client_auth")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterConfig) contextValidateClusterArch(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "cluster_arch", "body", string(m.ClusterArch)); err != nil {
		return err
	}

	return nil
}

func (m *ClusterConfig) contextValidateEncryptionStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.EncryptionStatus != nil {

		if swag.IsZero(m.EncryptionStatus) { // not required
			return nil
		}

		if err := m.EncryptionStatus.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("encryption_status")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("encryption_status")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterConfig) contextValidateExternalConfigurations(ctx context.Context, formats strfmt.Registry) error {

	if m.ExternalConfigurations != nil {

		if swag.IsZero(m.ExternalConfigurations) { // not required
			return nil
		}

		if err := m.ExternalConfigurations.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("external_configurations")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("external_configurations")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterConfig) contextValidateIsAvailable(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "is_available", "body", m.IsAvailable); err != nil {
		return err
	}

	return nil
}

func (m *ClusterConfig) contextValidateManagementServerList(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "management_server_list", "body", []*ClusterManagementServer(m.ManagementServerList)); err != nil {
		return err
	}

	for i := 0; i < len(m.ManagementServerList); i++ {

		if m.ManagementServerList[i] != nil {

			if swag.IsZero(m.ManagementServerList[i]) { // not required
				return nil
			}

			if err := m.ManagementServerList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("management_server_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("management_server_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterConfig) contextValidateOperationMode(ctx context.Context, formats strfmt.Registry) error {

	if swag.IsZero(m.OperationMode) { // not required
		return nil
	}

	if err := m.OperationMode.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("operation_mode")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("operation_mode")
		}
		return err
	}

	return nil
}

func (m *ClusterConfig) contextValidateServiceList(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_list", "body", ClusterServiceList(m.ServiceList)); err != nil {
		return err
	}

	if err := m.ServiceList.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("service_list")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("service_list")
		}
		return err
	}

	return nil
}

func (m *ClusterConfig) contextValidateSoftwareMap(ctx context.Context, formats strfmt.Registry) error {

	for k := range m.SoftwareMap {

		if val, ok := m.SoftwareMap[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *ClusterConfig) contextValidateSslKey(ctx context.Context, formats strfmt.Registry) error {

	if m.SslKey != nil {

		if swag.IsZero(m.SslKey) { // not required
			return nil
		}

		if err := m.SslKey.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ssl_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ssl_key")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterConfig) UnmarshalBinary(b []byte) error {
	var res ClusterConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
