// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ClusterConfigSpec Cluster Configuration
//
// Cluster Configuration.
//
// swagger:model cluster_config_spec
type ClusterConfigSpec struct {

	// List of valid ssh keys for the cluster.
	AuthorizedPublicKeyList []*PublicKey `json:"authorized_public_key_list"`

	// certification signing info
	CertificationSigningInfo *CertificationSigningInfo `json:"certification_signing_info,omitempty"`

	// client auth
	ClientAuth *ClientAuth `json:"client_auth,omitempty"`

	// Domain awareness supported on cluster.
	DomainAwarenessLevel *string `json:"domain_awareness_level,omitempty"`

	// Indicates if downsampling of metrics syncing between PE
	// and PC is enabled or not.
	//
	EnableEfficientMetricSync bool `json:"enable_efficient_metric_sync,omitempty"`

	// Array of enabled features.
	EnabledFeatureList []string `json:"enabled_feature_list"`

	// encryption status
	EncryptionStatus *EncryptionStatus `json:"encryption_status,omitempty"`

	// External Connector Configurations.
	ExternalConfigurations *ExternalConfigurationsSpec `json:"external_configurations,omitempty"`

	// GPU driver version.
	GpuDriverVersion string `json:"gpu_driver_version,omitempty"`

	// operation mode
	OperationMode ClusterOperationMode `json:"operation_mode,omitempty"`

	// Cluster supported redundancy factor. Default is 2.
	RedundancyFactor int32 `json:"redundancy_factor,omitempty"`

	// Map of software on the cluster with software type as the
	// key.
	//
	SoftwareMap map[string]ClusterSoftware `json:"software_map,omitempty"`

	// Verbosity level settings for populating support information.
	// - 'Nothing': Send nothing
	// - 'Basic': Send basic information - skip core dump and hypervisor
	//            stats information
	// - 'BasicPlusCoreDump': Send basic and core dump information
	// - 'All': Send all information
	//
	SupportedInformationVerbosity *string `json:"supported_information_verbosity,omitempty"`

	// Zone name used in value of TZ environment variable.
	Timezone string `json:"timezone,omitempty"`
}

// Validate validates this cluster config spec
func (m *ClusterConfigSpec) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAuthorizedPublicKeyList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCertificationSigningInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClientAuth(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEncryptionStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExternalConfigurations(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOperationMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSoftwareMap(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterConfigSpec) validateAuthorizedPublicKeyList(formats strfmt.Registry) error {
	if swag.IsZero(m.AuthorizedPublicKeyList) { // not required
		return nil
	}

	for i := 0; i < len(m.AuthorizedPublicKeyList); i++ {
		if swag.IsZero(m.AuthorizedPublicKeyList[i]) { // not required
			continue
		}

		if m.AuthorizedPublicKeyList[i] != nil {
			if err := m.AuthorizedPublicKeyList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("authorized_public_key_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("authorized_public_key_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterConfigSpec) validateCertificationSigningInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.CertificationSigningInfo) { // not required
		return nil
	}

	if m.CertificationSigningInfo != nil {
		if err := m.CertificationSigningInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("certification_signing_info")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("certification_signing_info")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterConfigSpec) validateClientAuth(formats strfmt.Registry) error {
	if swag.IsZero(m.ClientAuth) { // not required
		return nil
	}

	if m.ClientAuth != nil {
		if err := m.ClientAuth.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("client_auth")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("client_auth")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterConfigSpec) validateEncryptionStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.EncryptionStatus) { // not required
		return nil
	}

	if m.EncryptionStatus != nil {
		if err := m.EncryptionStatus.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("encryption_status")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("encryption_status")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterConfigSpec) validateExternalConfigurations(formats strfmt.Registry) error {
	if swag.IsZero(m.ExternalConfigurations) { // not required
		return nil
	}

	if m.ExternalConfigurations != nil {
		if err := m.ExternalConfigurations.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("external_configurations")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("external_configurations")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterConfigSpec) validateOperationMode(formats strfmt.Registry) error {
	if swag.IsZero(m.OperationMode) { // not required
		return nil
	}

	if err := m.OperationMode.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("operation_mode")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("operation_mode")
		}
		return err
	}

	return nil
}

func (m *ClusterConfigSpec) validateSoftwareMap(formats strfmt.Registry) error {
	if swag.IsZero(m.SoftwareMap) { // not required
		return nil
	}

	for k := range m.SoftwareMap {

		if err := validate.Required("software_map"+"."+k, "body", m.SoftwareMap[k]); err != nil {
			return err
		}
		if val, ok := m.SoftwareMap[k]; ok {
			if err := val.Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("software_map" + "." + k)
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("software_map" + "." + k)
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this cluster config spec based on the context it is used
func (m *ClusterConfigSpec) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAuthorizedPublicKeyList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCertificationSigningInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateClientAuth(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEncryptionStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExternalConfigurations(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOperationMode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSoftwareMap(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterConfigSpec) contextValidateAuthorizedPublicKeyList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AuthorizedPublicKeyList); i++ {

		if m.AuthorizedPublicKeyList[i] != nil {

			if swag.IsZero(m.AuthorizedPublicKeyList[i]) { // not required
				return nil
			}

			if err := m.AuthorizedPublicKeyList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("authorized_public_key_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("authorized_public_key_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterConfigSpec) contextValidateCertificationSigningInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.CertificationSigningInfo != nil {

		if swag.IsZero(m.CertificationSigningInfo) { // not required
			return nil
		}

		if err := m.CertificationSigningInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("certification_signing_info")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("certification_signing_info")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterConfigSpec) contextValidateClientAuth(ctx context.Context, formats strfmt.Registry) error {

	if m.ClientAuth != nil {

		if swag.IsZero(m.ClientAuth) { // not required
			return nil
		}

		if err := m.ClientAuth.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("client_auth")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("client_auth")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterConfigSpec) contextValidateEncryptionStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.EncryptionStatus != nil {

		if swag.IsZero(m.EncryptionStatus) { // not required
			return nil
		}

		if err := m.EncryptionStatus.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("encryption_status")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("encryption_status")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterConfigSpec) contextValidateExternalConfigurations(ctx context.Context, formats strfmt.Registry) error {

	if m.ExternalConfigurations != nil {

		if swag.IsZero(m.ExternalConfigurations) { // not required
			return nil
		}

		if err := m.ExternalConfigurations.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("external_configurations")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("external_configurations")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterConfigSpec) contextValidateOperationMode(ctx context.Context, formats strfmt.Registry) error {

	if swag.IsZero(m.OperationMode) { // not required
		return nil
	}

	if err := m.OperationMode.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("operation_mode")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("operation_mode")
		}
		return err
	}

	return nil
}

func (m *ClusterConfigSpec) contextValidateSoftwareMap(ctx context.Context, formats strfmt.Registry) error {

	for k := range m.SoftwareMap {

		if val, ok := m.SoftwareMap[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterConfigSpec) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterConfigSpec) UnmarshalBinary(b []byte) error {
	var res ClusterConfigSpec
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
