// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ClusterNetwork Cluster Network Configuration
//
// Cluster network.
//
// swagger:model cluster_network
type ClusterNetwork struct {

	// Configuration for the default vswitch (br0) present on all nodes of
	// this cluster. This is considered internal only and is not supported
	// on this version of AOS.
	//
	DefaultVswitchConfig *VswitchConfig `json:"default_vswitch_config,omitempty"`

	// domain server
	DomainServer *ClusterDomainServer `json:"domain_server,omitempty"`

	// The cluster IP address that provides external entities access to
	// various cluster data services.
	//
	// Pattern: ^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$
	ExternalDataServicesIP string `json:"external_data_services_ip,omitempty"`

	// The local IP of cluster visible externally.
	// Pattern: ^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$
	ExternalIP string `json:"external_ip,omitempty"`

	// External subnet for cross server communication. The format is
	// IP/netmask.
	//
	ExternalSubnet *string `json:"external_subnet,omitempty"`

	// fully qualified domain name of the cluster visible externally.
	FullyQualifiedDomainName string `json:"fully_qualified_domain_name,omitempty"`

	// List of proxies to connect to the service centers.
	HTTPProxyList []*ClusterNetworkEntity `json:"http_proxy_list"`

	// HTTP proxy whitelist.
	HTTPProxyWhitelist []*HTTPProxyWhitelist `json:"http_proxy_whitelist"`

	// The internal subnet is local to every server - its not visible
	// outside.iSCSI requests generated internally within the appliance
	// (by user VMs or VMFS) are sent to the internal subnet. The format is
	// IP/netmask.
	//
	InternalSubnet *string `json:"internal_subnet,omitempty"`

	// The cluster NAT'd or proxy IP which maps to the cluster local IP.
	//
	// Pattern: ^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$
	MasqueradingIP string `json:"masquerading_ip,omitempty"`

	// Port used together with masquerading_ip to connect to the cluster.
	//
	MasqueradingPort int32 `json:"masquerading_port,omitempty"`

	// The list of IP addresses of the name servers.
	NameServerIPList []string `json:"name_server_ip_list"`

	// Comma separated list of subnets (of the form 'a.b.c.d/l.m.n.o') that
	// are allowed to send NFS requests to this container. If not specified,
	// the global NFS whitelist will be looked up for access permission.
	// The internal subnet is always automatically considered part of the
	// whitelist, even if the field below does not explicitly specify it.
	// Similarly, all the hypervisor IPs are considered part of the
	// whitelist. Finally, to permit debugging, all of the SVMs local IPs
	// are considered to be implicitly part of the whitelist.
	//
	NfsSubnetWhitelist []string `json:"nfs_subnet_whitelist"`

	// The list of IP addresses or FQDNs of the NTP servers.
	NtpServerIPList []string `json:"ntp_server_ip_list"`

	// smtp server
	SMTPServer *SMTPServer `json:"smtp_server,omitempty"`
}

// Validate validates this cluster network
func (m *ClusterNetwork) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDefaultVswitchConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDomainServer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExternalDataServicesIP(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExternalIP(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHTTPProxyList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHTTPProxyWhitelist(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMasqueradingIP(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNameServerIPList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSMTPServer(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNetwork) validateDefaultVswitchConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.DefaultVswitchConfig) { // not required
		return nil
	}

	if m.DefaultVswitchConfig != nil {
		if err := m.DefaultVswitchConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("default_vswitch_config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("default_vswitch_config")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNetwork) validateDomainServer(formats strfmt.Registry) error {
	if swag.IsZero(m.DomainServer) { // not required
		return nil
	}

	if m.DomainServer != nil {
		if err := m.DomainServer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("domain_server")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("domain_server")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNetwork) validateExternalDataServicesIP(formats strfmt.Registry) error {
	if swag.IsZero(m.ExternalDataServicesIP) { // not required
		return nil
	}

	if err := validate.Pattern("external_data_services_ip", "body", m.ExternalDataServicesIP, `^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$`); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNetwork) validateExternalIP(formats strfmt.Registry) error {
	if swag.IsZero(m.ExternalIP) { // not required
		return nil
	}

	if err := validate.Pattern("external_ip", "body", m.ExternalIP, `^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$`); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNetwork) validateHTTPProxyList(formats strfmt.Registry) error {
	if swag.IsZero(m.HTTPProxyList) { // not required
		return nil
	}

	for i := 0; i < len(m.HTTPProxyList); i++ {
		if swag.IsZero(m.HTTPProxyList[i]) { // not required
			continue
		}

		if m.HTTPProxyList[i] != nil {
			if err := m.HTTPProxyList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("http_proxy_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("http_proxy_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterNetwork) validateHTTPProxyWhitelist(formats strfmt.Registry) error {
	if swag.IsZero(m.HTTPProxyWhitelist) { // not required
		return nil
	}

	for i := 0; i < len(m.HTTPProxyWhitelist); i++ {
		if swag.IsZero(m.HTTPProxyWhitelist[i]) { // not required
			continue
		}

		if m.HTTPProxyWhitelist[i] != nil {
			if err := m.HTTPProxyWhitelist[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("http_proxy_whitelist" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("http_proxy_whitelist" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterNetwork) validateMasqueradingIP(formats strfmt.Registry) error {
	if swag.IsZero(m.MasqueradingIP) { // not required
		return nil
	}

	if err := validate.Pattern("masquerading_ip", "body", m.MasqueradingIP, `^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$`); err != nil {
		return err
	}

	return nil
}

func (m *ClusterNetwork) validateNameServerIPList(formats strfmt.Registry) error {
	if swag.IsZero(m.NameServerIPList) { // not required
		return nil
	}

	for i := 0; i < len(m.NameServerIPList); i++ {

		if err := validate.Pattern("name_server_ip_list"+"."+strconv.Itoa(i), "body", m.NameServerIPList[i], `^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$`); err != nil {
			return err
		}

	}

	return nil
}

func (m *ClusterNetwork) validateSMTPServer(formats strfmt.Registry) error {
	if swag.IsZero(m.SMTPServer) { // not required
		return nil
	}

	if m.SMTPServer != nil {
		if err := m.SMTPServer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("smtp_server")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("smtp_server")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster network based on the context it is used
func (m *ClusterNetwork) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDefaultVswitchConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDomainServer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHTTPProxyList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHTTPProxyWhitelist(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSMTPServer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNetwork) contextValidateDefaultVswitchConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.DefaultVswitchConfig != nil {

		if swag.IsZero(m.DefaultVswitchConfig) { // not required
			return nil
		}

		if err := m.DefaultVswitchConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("default_vswitch_config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("default_vswitch_config")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNetwork) contextValidateDomainServer(ctx context.Context, formats strfmt.Registry) error {

	if m.DomainServer != nil {

		if swag.IsZero(m.DomainServer) { // not required
			return nil
		}

		if err := m.DomainServer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("domain_server")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("domain_server")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterNetwork) contextValidateHTTPProxyList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.HTTPProxyList); i++ {

		if m.HTTPProxyList[i] != nil {

			if swag.IsZero(m.HTTPProxyList[i]) { // not required
				return nil
			}

			if err := m.HTTPProxyList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("http_proxy_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("http_proxy_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterNetwork) contextValidateHTTPProxyWhitelist(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.HTTPProxyWhitelist); i++ {

		if m.HTTPProxyWhitelist[i] != nil {

			if swag.IsZero(m.HTTPProxyWhitelist[i]) { // not required
				return nil
			}

			if err := m.HTTPProxyWhitelist[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("http_proxy_whitelist" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("http_proxy_whitelist" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterNetwork) contextValidateSMTPServer(ctx context.Context, formats strfmt.Registry) error {

	if m.SMTPServer != nil {

		if swag.IsZero(m.SMTPServer) { // not required
			return nil
		}

		if err := m.SMTPServer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("smtp_server")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("smtp_server")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterNetwork) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterNetwork) UnmarshalBinary(b []byte) error {
	var res ClusterNetwork
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
