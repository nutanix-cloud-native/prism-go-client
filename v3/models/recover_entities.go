// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// RecoverEntities Information about entities to be recovered
//
// Information about entities to be recovered.
//
// swagger:model recover_entities
type RecoverEntities struct {

	// Information about entities to be recovered as part of this stage. For VM, entity information will include set of scripts to be executed after recovery of VM. Only one of categories or any_entity_reference has to be provided.
	//
	// Required: true
	EntityInfoList []*RecoverEntitiesEntityInfoListItems0 `json:"entity_info_list"`
}

// Validate validates this recover entities
func (m *RecoverEntities) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEntityInfoList(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RecoverEntities) validateEntityInfoList(formats strfmt.Registry) error {

	if err := validate.Required("entity_info_list", "body", m.EntityInfoList); err != nil {
		return err
	}

	for i := 0; i < len(m.EntityInfoList); i++ {
		if swag.IsZero(m.EntityInfoList[i]) { // not required
			continue
		}

		if m.EntityInfoList[i] != nil {
			if err := m.EntityInfoList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("entity_info_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("entity_info_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this recover entities based on the context it is used
func (m *RecoverEntities) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateEntityInfoList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RecoverEntities) contextValidateEntityInfoList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.EntityInfoList); i++ {

		if m.EntityInfoList[i] != nil {

			if swag.IsZero(m.EntityInfoList[i]) { // not required
				return nil
			}

			if err := m.EntityInfoList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("entity_info_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("entity_info_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *RecoverEntities) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RecoverEntities) UnmarshalBinary(b []byte) error {
	var res RecoverEntities
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// RecoverEntitiesEntityInfoListItems0 recover entities entity info list items0
//
// swagger:model RecoverEntitiesEntityInfoListItems0
type RecoverEntitiesEntityInfoListItems0 struct {

	// Information about entity to be recovered.
	AnyEntityReference *Reference `json:"any_entity_reference,omitempty"`

	// Categories for filtering entities.
	Categories map[string]string `json:"categories,omitempty"`

	// List of scripts to be executed inside the guest VMs after recovery.
	//
	ScriptList []*RecoveryPlanScriptConfig `json:"script_list"`

	// Power state of the VM(s) after recovery.
	VMPowerState string `json:"vm_power_state,omitempty"`

	// List containing the VMs to Volume Group attachment information.
	//
	VolumeGroupAttachmentList []*RecoverEntitiesEntityInfoListItems0VolumeGroupAttachmentListItems0 `json:"volume_group_attachment_list"`
}

// Validate validates this recover entities entity info list items0
func (m *RecoverEntitiesEntityInfoListItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAnyEntityReference(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScriptList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVolumeGroupAttachmentList(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RecoverEntitiesEntityInfoListItems0) validateAnyEntityReference(formats strfmt.Registry) error {
	if swag.IsZero(m.AnyEntityReference) { // not required
		return nil
	}

	if m.AnyEntityReference != nil {
		if err := m.AnyEntityReference.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("any_entity_reference")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("any_entity_reference")
			}
			return err
		}
	}

	return nil
}

func (m *RecoverEntitiesEntityInfoListItems0) validateScriptList(formats strfmt.Registry) error {
	if swag.IsZero(m.ScriptList) { // not required
		return nil
	}

	for i := 0; i < len(m.ScriptList); i++ {
		if swag.IsZero(m.ScriptList[i]) { // not required
			continue
		}

		if m.ScriptList[i] != nil {
			if err := m.ScriptList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("script_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("script_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RecoverEntitiesEntityInfoListItems0) validateVolumeGroupAttachmentList(formats strfmt.Registry) error {
	if swag.IsZero(m.VolumeGroupAttachmentList) { // not required
		return nil
	}

	for i := 0; i < len(m.VolumeGroupAttachmentList); i++ {
		if swag.IsZero(m.VolumeGroupAttachmentList[i]) { // not required
			continue
		}

		if m.VolumeGroupAttachmentList[i] != nil {
			if err := m.VolumeGroupAttachmentList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("volume_group_attachment_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("volume_group_attachment_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this recover entities entity info list items0 based on the context it is used
func (m *RecoverEntitiesEntityInfoListItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAnyEntityReference(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateScriptList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVolumeGroupAttachmentList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RecoverEntitiesEntityInfoListItems0) contextValidateAnyEntityReference(ctx context.Context, formats strfmt.Registry) error {

	if m.AnyEntityReference != nil {

		if swag.IsZero(m.AnyEntityReference) { // not required
			return nil
		}

		if err := m.AnyEntityReference.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("any_entity_reference")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("any_entity_reference")
			}
			return err
		}
	}

	return nil
}

func (m *RecoverEntitiesEntityInfoListItems0) contextValidateScriptList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ScriptList); i++ {

		if m.ScriptList[i] != nil {

			if swag.IsZero(m.ScriptList[i]) { // not required
				return nil
			}

			if err := m.ScriptList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("script_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("script_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RecoverEntitiesEntityInfoListItems0) contextValidateVolumeGroupAttachmentList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.VolumeGroupAttachmentList); i++ {

		if m.VolumeGroupAttachmentList[i] != nil {

			if swag.IsZero(m.VolumeGroupAttachmentList[i]) { // not required
				return nil
			}

			if err := m.VolumeGroupAttachmentList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("volume_group_attachment_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("volume_group_attachment_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *RecoverEntitiesEntityInfoListItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RecoverEntitiesEntityInfoListItems0) UnmarshalBinary(b []byte) error {
	var res RecoverEntitiesEntityInfoListItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// RecoverEntitiesEntityInfoListItems0VolumeGroupAttachmentListItems0 recover entities entity info list items0 volume group attachment list items0
//
// swagger:model RecoverEntitiesEntityInfoListItems0VolumeGroupAttachmentListItems0
type RecoverEntitiesEntityInfoListItems0VolumeGroupAttachmentListItems0 struct {

	// Reference of the VM to which Volume Group is to be attached. The VM specified here must be among those either specified explicitly in "any_entity_reference" or have categories as specified in the "categories" filter.
	//
	// Required: true
	VMReference *VMReference `json:"vm_reference"`

	// Information about Volume Groups to be attached.
	//
	// Required: true
	// Min Items: 1
	VolumeGroupAttachmentInfoList []*RecoverEntitiesEntityInfoListItems0VolumeGroupAttachmentListItems0VolumeGroupAttachmentInfoListItems0 `json:"volume_group_attachment_info_list"`
}

// Validate validates this recover entities entity info list items0 volume group attachment list items0
func (m *RecoverEntitiesEntityInfoListItems0VolumeGroupAttachmentListItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateVMReference(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVolumeGroupAttachmentInfoList(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RecoverEntitiesEntityInfoListItems0VolumeGroupAttachmentListItems0) validateVMReference(formats strfmt.Registry) error {

	if err := validate.Required("vm_reference", "body", m.VMReference); err != nil {
		return err
	}

	if m.VMReference != nil {
		if err := m.VMReference.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vm_reference")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vm_reference")
			}
			return err
		}
	}

	return nil
}

func (m *RecoverEntitiesEntityInfoListItems0VolumeGroupAttachmentListItems0) validateVolumeGroupAttachmentInfoList(formats strfmt.Registry) error {

	if err := validate.Required("volume_group_attachment_info_list", "body", m.VolumeGroupAttachmentInfoList); err != nil {
		return err
	}

	iVolumeGroupAttachmentInfoListSize := int64(len(m.VolumeGroupAttachmentInfoList))

	if err := validate.MinItems("volume_group_attachment_info_list", "body", iVolumeGroupAttachmentInfoListSize, 1); err != nil {
		return err
	}

	for i := 0; i < len(m.VolumeGroupAttachmentInfoList); i++ {
		if swag.IsZero(m.VolumeGroupAttachmentInfoList[i]) { // not required
			continue
		}

		if m.VolumeGroupAttachmentInfoList[i] != nil {
			if err := m.VolumeGroupAttachmentInfoList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("volume_group_attachment_info_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("volume_group_attachment_info_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this recover entities entity info list items0 volume group attachment list items0 based on the context it is used
func (m *RecoverEntitiesEntityInfoListItems0VolumeGroupAttachmentListItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateVMReference(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVolumeGroupAttachmentInfoList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RecoverEntitiesEntityInfoListItems0VolumeGroupAttachmentListItems0) contextValidateVMReference(ctx context.Context, formats strfmt.Registry) error {

	if m.VMReference != nil {

		if err := m.VMReference.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vm_reference")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vm_reference")
			}
			return err
		}
	}

	return nil
}

func (m *RecoverEntitiesEntityInfoListItems0VolumeGroupAttachmentListItems0) contextValidateVolumeGroupAttachmentInfoList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.VolumeGroupAttachmentInfoList); i++ {

		if m.VolumeGroupAttachmentInfoList[i] != nil {

			if swag.IsZero(m.VolumeGroupAttachmentInfoList[i]) { // not required
				return nil
			}

			if err := m.VolumeGroupAttachmentInfoList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("volume_group_attachment_info_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("volume_group_attachment_info_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *RecoverEntitiesEntityInfoListItems0VolumeGroupAttachmentListItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RecoverEntitiesEntityInfoListItems0VolumeGroupAttachmentListItems0) UnmarshalBinary(b []byte) error {
	var res RecoverEntitiesEntityInfoListItems0VolumeGroupAttachmentListItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// RecoverEntitiesEntityInfoListItems0VolumeGroupAttachmentListItems0VolumeGroupAttachmentInfoListItems0 recover entities entity info list items0 volume group attachment list items0 volume group attachment info list items0
//
// swagger:model RecoverEntitiesEntityInfoListItems0VolumeGroupAttachmentListItems0VolumeGroupAttachmentInfoListItems0
type RecoverEntitiesEntityInfoListItems0VolumeGroupAttachmentListItems0VolumeGroupAttachmentInfoListItems0 struct {

	// Mechanism to be used for Volume Group attachment. The allowed attachment types are IQN, HYPERVISOR. Specify IQN in case of "iSCSI Qualified Name" based attachments. In case of IQN based attachment, authentication_type, client_secret can be specified for client authentication. Specify HYPERVISOR for directly attaching Volumes to VM through the hypervisor, this is only supported when VM is running on AHV hypervisor."
	//
	// Required: true
	AttachmentType *string `json:"attachment_type"`

	// Type of authentication protocol to be used.
	//
	AuthenticationType string `json:"authentication_type,omitempty"`

	// Client secret in case of CHAP authentication is required.
	//
	// Max Length: 16
	// Min Length: 12
	// Format: password
	ClientSecret strfmt.Password `json:"client_secret,omitempty"`

	// Reference of the Volume Group to be attached. The Volume Groups specified here must be among those specified explicitly or via category filter in the "volume_group_recovery_info_list".
	//
	// Required: true
	VolumeGroupReference *VolumeGroupReference `json:"volume_group_reference"`
}

// Validate validates this recover entities entity info list items0 volume group attachment list items0 volume group attachment info list items0
func (m *RecoverEntitiesEntityInfoListItems0VolumeGroupAttachmentListItems0VolumeGroupAttachmentInfoListItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAttachmentType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClientSecret(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVolumeGroupReference(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RecoverEntitiesEntityInfoListItems0VolumeGroupAttachmentListItems0VolumeGroupAttachmentInfoListItems0) validateAttachmentType(formats strfmt.Registry) error {

	if err := validate.Required("attachment_type", "body", m.AttachmentType); err != nil {
		return err
	}

	return nil
}

func (m *RecoverEntitiesEntityInfoListItems0VolumeGroupAttachmentListItems0VolumeGroupAttachmentInfoListItems0) validateClientSecret(formats strfmt.Registry) error {
	if swag.IsZero(m.ClientSecret) { // not required
		return nil
	}

	if err := validate.MinLength("client_secret", "body", m.ClientSecret.String(), 12); err != nil {
		return err
	}

	if err := validate.MaxLength("client_secret", "body", m.ClientSecret.String(), 16); err != nil {
		return err
	}

	if err := validate.FormatOf("client_secret", "body", "password", m.ClientSecret.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *RecoverEntitiesEntityInfoListItems0VolumeGroupAttachmentListItems0VolumeGroupAttachmentInfoListItems0) validateVolumeGroupReference(formats strfmt.Registry) error {

	if err := validate.Required("volume_group_reference", "body", m.VolumeGroupReference); err != nil {
		return err
	}

	if m.VolumeGroupReference != nil {
		if err := m.VolumeGroupReference.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("volume_group_reference")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("volume_group_reference")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this recover entities entity info list items0 volume group attachment list items0 volume group attachment info list items0 based on the context it is used
func (m *RecoverEntitiesEntityInfoListItems0VolumeGroupAttachmentListItems0VolumeGroupAttachmentInfoListItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateVolumeGroupReference(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RecoverEntitiesEntityInfoListItems0VolumeGroupAttachmentListItems0VolumeGroupAttachmentInfoListItems0) contextValidateVolumeGroupReference(ctx context.Context, formats strfmt.Registry) error {

	if m.VolumeGroupReference != nil {

		if err := m.VolumeGroupReference.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("volume_group_reference")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("volume_group_reference")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RecoverEntitiesEntityInfoListItems0VolumeGroupAttachmentListItems0VolumeGroupAttachmentInfoListItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RecoverEntitiesEntityInfoListItems0VolumeGroupAttachmentListItems0VolumeGroupAttachmentInfoListItems0) UnmarshalBinary(b []byte) error {
	var res RecoverEntitiesEntityInfoListItems0VolumeGroupAttachmentListItems0VolumeGroupAttachmentInfoListItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
