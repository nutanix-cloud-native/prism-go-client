// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// RecoveryPlanResources Recovery Plan resources
//
// # Recovery Plan resources
//
// swagger:model recovery_plan_resources
type RecoveryPlanResources struct {

	// parameters
	Parameters *RecoveryPlanResourcesParameters `json:"parameters,omitempty"`

	// Input for the stages of the Recovery Plan. Each stage will perform a predefined type of task. For example, a stage can perform the recovery of the entities specified in a stage.
	//
	StageList []*RecoveryPlanStage `json:"stage_list"`

	// Information about Volume Groups to be recovered.
	VolumeGroupRecoveryInfoList []*RecoveryPlanVolumeGroupRecoveryInfo `json:"volume_group_recovery_info_list"`
}

// Validate validates this recovery plan resources
func (m *RecoveryPlanResources) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateParameters(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStageList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVolumeGroupRecoveryInfoList(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RecoveryPlanResources) validateParameters(formats strfmt.Registry) error {
	if swag.IsZero(m.Parameters) { // not required
		return nil
	}

	if m.Parameters != nil {
		if err := m.Parameters.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("parameters")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("parameters")
			}
			return err
		}
	}

	return nil
}

func (m *RecoveryPlanResources) validateStageList(formats strfmt.Registry) error {
	if swag.IsZero(m.StageList) { // not required
		return nil
	}

	for i := 0; i < len(m.StageList); i++ {
		if swag.IsZero(m.StageList[i]) { // not required
			continue
		}

		if m.StageList[i] != nil {
			if err := m.StageList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("stage_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("stage_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RecoveryPlanResources) validateVolumeGroupRecoveryInfoList(formats strfmt.Registry) error {
	if swag.IsZero(m.VolumeGroupRecoveryInfoList) { // not required
		return nil
	}

	for i := 0; i < len(m.VolumeGroupRecoveryInfoList); i++ {
		if swag.IsZero(m.VolumeGroupRecoveryInfoList[i]) { // not required
			continue
		}

		if m.VolumeGroupRecoveryInfoList[i] != nil {
			if err := m.VolumeGroupRecoveryInfoList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("volume_group_recovery_info_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("volume_group_recovery_info_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this recovery plan resources based on the context it is used
func (m *RecoveryPlanResources) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateParameters(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStageList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVolumeGroupRecoveryInfoList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RecoveryPlanResources) contextValidateParameters(ctx context.Context, formats strfmt.Registry) error {

	if m.Parameters != nil {

		if swag.IsZero(m.Parameters) { // not required
			return nil
		}

		if err := m.Parameters.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("parameters")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("parameters")
			}
			return err
		}
	}

	return nil
}

func (m *RecoveryPlanResources) contextValidateStageList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.StageList); i++ {

		if m.StageList[i] != nil {

			if swag.IsZero(m.StageList[i]) { // not required
				return nil
			}

			if err := m.StageList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("stage_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("stage_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RecoveryPlanResources) contextValidateVolumeGroupRecoveryInfoList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.VolumeGroupRecoveryInfoList); i++ {

		if m.VolumeGroupRecoveryInfoList[i] != nil {

			if swag.IsZero(m.VolumeGroupRecoveryInfoList[i]) { // not required
				return nil
			}

			if err := m.VolumeGroupRecoveryInfoList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("volume_group_recovery_info_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("volume_group_recovery_info_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *RecoveryPlanResources) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RecoveryPlanResources) UnmarshalBinary(b []byte) error {
	var res RecoveryPlanResources
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// RecoveryPlanResourcesParameters Parameters for the Recovery Plan.
//
// swagger:model RecoveryPlanResourcesParameters
type RecoveryPlanResourcesParameters struct {

	// A list containing information about primary and secondary Availability zones.
	//
	AvailabilityZoneList []*AvailabilityZoneInformation `json:"availability_zone_list"`

	// An option to specify cutover mode for VM/Volume Group when restoring data from recovery point present at any storage over the network. EARLY - VM/Volume Group will be made available for active
	//   consumption before completely hydrating the data for them from
	//   the recovery point available over the remote network storage.
	//   Hydration of data will keep happening in the background for the
	//   recovered VMs/Volume Groups.
	// LATE - VM/Volume Group will be made available for active
	//   consumption after completely hydrating the data for them from
	//   the recovery point available over the remote network storage.
	//
	CutoverMode string `json:"cutover_mode,omitempty"`

	// IP address mappings for attaching Volume Groups to VMs upon failover.
	//
	DataServiceIPMappingList []*RecoveryPlanResourcesParametersDataServiceIPMappingListItems0 `json:"data_service_ip_mapping_list"`

	// Floating IP assignment for VMs upon recovery in an Availability Zone. For example, Let RFIP1 and TFIP1 denote the recovery and test floating IPs respectively on AZ1 and RFIP2 and TFIP2 denote the recovery and test floating IPs respectively on AZ2. Let's say that we want to specify floating IP mapping for VM1, which is present on AZ1 and has a vNIC1 attached to it. Following matrix specifies the mapping: [(AZ1: [(VM1 vNIC1 RFIP1 TFIP1)]), AZ2: [(VM1 vNIC1 RFIP2 TFIP2)]] As per the above matrix, while performing planned/unplanned failover action from Availability Zone AZ1 to AZ2, vNIC1 will recover on AZ2 with RFIP2. In case of test failover, vNIC1 will recover on AZ2 with TFIP2.
	//
	FloatingIPAssignmentList []*RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0 `json:"floating_ip_assignment_list"`

	// Network mappings to be used for the Recovery Plan. This will be represented by array of network mappings across the Availability Zones. Each entry of network mapping will have Availability Zone URL, recovery and test network information, static IP assignment for the VMs for the recovery and test networks. For example, Let RNx, TNx denote the recovery and test network information and RIPMx, TIPMx denote the static IP assignment for the VMs. As per below matrix, while performing failover action from Availability Zone AZ1 to AZ2, RN1 will be mapped to RN4 and static IP "a.b.c.d" of the VM with reference VMx will be mapped to "i.j.k.l". On performing test failover from AZ1 to AZ2, RN1 will be mapped to TN4 and static IP "a.b.c.d" of the VM with reference VMx will be mapped to "I.J.K.L". [[(AZ1 URL, RN1, TN1, [{VMx, "a.b.c.d"}, {VMy, "e.f.g.h"}],
	//    [{VMx, "A.B.C.D"}, {VMy, "E.F.G.H"}]),
	//   (AZ2 URL, RN4, TN4, [{VMx, "i.j.k.l"}, {VMy, "m.n.p.q"}],
	//    [{VMx, "I.J.K.L"}, {VMy, "M.N.P.Q"}]),
	//   (AZ3 URL, RN7, TN7)],
	//  [(AZ1 URL, RN2, TN2), (AZ2 URL, RN5, TN5),
	//   (AZ3 URL, RN8, TN8)],
	//  [(AZ1 URL, RN3, TN3), (AZ2 URL, RN6, TN6)]]
	// The order of the static IP assignment for the VMs should remain same across all the networks provided in a network mapping. It forms a matrix containing IP mapping for the VMs across the Availability Zones. If a VM has multiple static IP addresses, static IP mapping will happen on the array indices. For example, Let IPrxy denote an IP address in subnet RNz and IPtxy denote an IP address in the subnet TNz. Lets VMx has two static IP address and VMy, VMz has one static IP associated with a vNIC created in network RN1. The IP mapping for the VMs will be as below.
	//     AZ1, RN1        AZ1, TN1        AZ2, RN3        AZ2, TN2
	// [(VMx, [IPr11]), (VMx, [IPt11]), (VMx, [IPr12]), (VMx,  [IPt12])] [(VMy, [IPr21]), (VMy, [IPt21]), (VMy, [IPr22]), (VMy,  [IPt22])] [(VMz, [IPr31]), (VMz, [IPt31]), (VMz, [IPr32]), (VMz,  [IPt32])]
	// In case of recovery of VMs from one Prism Element to the other within the same Availability Zone, a list of cluster references where the network exists can be specified. The network mapping to be used for a vNIC is decided as follows -
	// 1. If a VM that has a vNIC in a network N1 on cluster C1, then
	//    the network mapping of N1 that has C1 in the cluster
	//    references list will be used.
	//
	// 2. In case there is no network mapping for N1 with cluster C1,
	//    the default mapping of N1 for the Availability Zone (in which
	//    cluster is not specified), will be used if present.
	//
	NetworkMappingList []*RecoveryPlanResourcesParametersNetworkMappingListItems0 `json:"network_mapping_list"`

	// This field should be set to the index of the Availability Zone in the availability_zone_list which should be considered as a protected Availability Zone.
	//
	PrimaryLocationIndex int64 `json:"primary_location_index"`

	// A list containing witness configuration.
	//
	// Max Items: 1
	WitnessConfigurationList []*WitnessConfiguration `json:"witness_configuration_list"`
}

// Validate validates this recovery plan resources parameters
func (m *RecoveryPlanResourcesParameters) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAvailabilityZoneList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDataServiceIPMappingList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFloatingIPAssignmentList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetworkMappingList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWitnessConfigurationList(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RecoveryPlanResourcesParameters) validateAvailabilityZoneList(formats strfmt.Registry) error {
	if swag.IsZero(m.AvailabilityZoneList) { // not required
		return nil
	}

	for i := 0; i < len(m.AvailabilityZoneList); i++ {
		if swag.IsZero(m.AvailabilityZoneList[i]) { // not required
			continue
		}

		if m.AvailabilityZoneList[i] != nil {
			if err := m.AvailabilityZoneList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("parameters" + "." + "availability_zone_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("parameters" + "." + "availability_zone_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RecoveryPlanResourcesParameters) validateDataServiceIPMappingList(formats strfmt.Registry) error {
	if swag.IsZero(m.DataServiceIPMappingList) { // not required
		return nil
	}

	for i := 0; i < len(m.DataServiceIPMappingList); i++ {
		if swag.IsZero(m.DataServiceIPMappingList[i]) { // not required
			continue
		}

		if m.DataServiceIPMappingList[i] != nil {
			if err := m.DataServiceIPMappingList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("parameters" + "." + "data_service_ip_mapping_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("parameters" + "." + "data_service_ip_mapping_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RecoveryPlanResourcesParameters) validateFloatingIPAssignmentList(formats strfmt.Registry) error {
	if swag.IsZero(m.FloatingIPAssignmentList) { // not required
		return nil
	}

	for i := 0; i < len(m.FloatingIPAssignmentList); i++ {
		if swag.IsZero(m.FloatingIPAssignmentList[i]) { // not required
			continue
		}

		if m.FloatingIPAssignmentList[i] != nil {
			if err := m.FloatingIPAssignmentList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("parameters" + "." + "floating_ip_assignment_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("parameters" + "." + "floating_ip_assignment_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RecoveryPlanResourcesParameters) validateNetworkMappingList(formats strfmt.Registry) error {
	if swag.IsZero(m.NetworkMappingList) { // not required
		return nil
	}

	for i := 0; i < len(m.NetworkMappingList); i++ {
		if swag.IsZero(m.NetworkMappingList[i]) { // not required
			continue
		}

		if m.NetworkMappingList[i] != nil {
			if err := m.NetworkMappingList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("parameters" + "." + "network_mapping_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("parameters" + "." + "network_mapping_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RecoveryPlanResourcesParameters) validateWitnessConfigurationList(formats strfmt.Registry) error {
	if swag.IsZero(m.WitnessConfigurationList) { // not required
		return nil
	}

	iWitnessConfigurationListSize := int64(len(m.WitnessConfigurationList))

	if err := validate.MaxItems("parameters"+"."+"witness_configuration_list", "body", iWitnessConfigurationListSize, 1); err != nil {
		return err
	}

	for i := 0; i < len(m.WitnessConfigurationList); i++ {
		if swag.IsZero(m.WitnessConfigurationList[i]) { // not required
			continue
		}

		if m.WitnessConfigurationList[i] != nil {
			if err := m.WitnessConfigurationList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("parameters" + "." + "witness_configuration_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("parameters" + "." + "witness_configuration_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this recovery plan resources parameters based on the context it is used
func (m *RecoveryPlanResourcesParameters) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAvailabilityZoneList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDataServiceIPMappingList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFloatingIPAssignmentList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNetworkMappingList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateWitnessConfigurationList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RecoveryPlanResourcesParameters) contextValidateAvailabilityZoneList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AvailabilityZoneList); i++ {

		if m.AvailabilityZoneList[i] != nil {

			if swag.IsZero(m.AvailabilityZoneList[i]) { // not required
				return nil
			}

			if err := m.AvailabilityZoneList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("parameters" + "." + "availability_zone_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("parameters" + "." + "availability_zone_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RecoveryPlanResourcesParameters) contextValidateDataServiceIPMappingList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.DataServiceIPMappingList); i++ {

		if m.DataServiceIPMappingList[i] != nil {

			if swag.IsZero(m.DataServiceIPMappingList[i]) { // not required
				return nil
			}

			if err := m.DataServiceIPMappingList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("parameters" + "." + "data_service_ip_mapping_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("parameters" + "." + "data_service_ip_mapping_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RecoveryPlanResourcesParameters) contextValidateFloatingIPAssignmentList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.FloatingIPAssignmentList); i++ {

		if m.FloatingIPAssignmentList[i] != nil {

			if swag.IsZero(m.FloatingIPAssignmentList[i]) { // not required
				return nil
			}

			if err := m.FloatingIPAssignmentList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("parameters" + "." + "floating_ip_assignment_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("parameters" + "." + "floating_ip_assignment_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RecoveryPlanResourcesParameters) contextValidateNetworkMappingList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.NetworkMappingList); i++ {

		if m.NetworkMappingList[i] != nil {

			if swag.IsZero(m.NetworkMappingList[i]) { // not required
				return nil
			}

			if err := m.NetworkMappingList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("parameters" + "." + "network_mapping_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("parameters" + "." + "network_mapping_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RecoveryPlanResourcesParameters) contextValidateWitnessConfigurationList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.WitnessConfigurationList); i++ {

		if m.WitnessConfigurationList[i] != nil {

			if swag.IsZero(m.WitnessConfigurationList[i]) { // not required
				return nil
			}

			if err := m.WitnessConfigurationList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("parameters" + "." + "witness_configuration_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("parameters" + "." + "witness_configuration_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *RecoveryPlanResourcesParameters) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RecoveryPlanResourcesParameters) UnmarshalBinary(b []byte) error {
	var res RecoveryPlanResourcesParameters
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// RecoveryPlanResourcesParametersDataServiceIPMappingListItems0 recovery plan resources parameters data service IP mapping list items0
//
// swagger:model RecoveryPlanResourcesParametersDataServiceIPMappingListItems0
type RecoveryPlanResourcesParametersDataServiceIPMappingListItems0 struct {

	// Data Services IP address mapping, each entry in this mapping will include Availability Zone URL, Cluster reference, recovery and test data services IP. During the Volume Groups attachment step of Recovery Plan failover operation , the data service IP specified for the target Cluster will be reconfigured in the VMs.
	//
	// Max Items: 2
	// Min Items: 2
	DataServiceIPMapping []*RecoveryPlanDataServiceIPConfig `json:"data_service_ip_mapping"`
}

// Validate validates this recovery plan resources parameters data service IP mapping list items0
func (m *RecoveryPlanResourcesParametersDataServiceIPMappingListItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDataServiceIPMapping(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RecoveryPlanResourcesParametersDataServiceIPMappingListItems0) validateDataServiceIPMapping(formats strfmt.Registry) error {
	if swag.IsZero(m.DataServiceIPMapping) { // not required
		return nil
	}

	iDataServiceIPMappingSize := int64(len(m.DataServiceIPMapping))

	if err := validate.MinItems("data_service_ip_mapping", "body", iDataServiceIPMappingSize, 2); err != nil {
		return err
	}

	if err := validate.MaxItems("data_service_ip_mapping", "body", iDataServiceIPMappingSize, 2); err != nil {
		return err
	}

	for i := 0; i < len(m.DataServiceIPMapping); i++ {
		if swag.IsZero(m.DataServiceIPMapping[i]) { // not required
			continue
		}

		if m.DataServiceIPMapping[i] != nil {
			if err := m.DataServiceIPMapping[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("data_service_ip_mapping" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("data_service_ip_mapping" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this recovery plan resources parameters data service IP mapping list items0 based on the context it is used
func (m *RecoveryPlanResourcesParametersDataServiceIPMappingListItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDataServiceIPMapping(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RecoveryPlanResourcesParametersDataServiceIPMappingListItems0) contextValidateDataServiceIPMapping(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.DataServiceIPMapping); i++ {

		if m.DataServiceIPMapping[i] != nil {

			if swag.IsZero(m.DataServiceIPMapping[i]) { // not required
				return nil
			}

			if err := m.DataServiceIPMapping[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("data_service_ip_mapping" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("data_service_ip_mapping" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *RecoveryPlanResourcesParametersDataServiceIPMappingListItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RecoveryPlanResourcesParametersDataServiceIPMappingListItems0) UnmarshalBinary(b []byte) error {
	var res RecoveryPlanResourcesParametersDataServiceIPMappingListItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0 recovery plan resources parameters floating IP assignment list items0
//
// swagger:model RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0
type RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0 struct {

	// URL of the Availability Zone.
	//
	// Required: true
	AvailabilityZoneURL *string `json:"availability_zone_url"`

	// IP assignment for VMs upon recovery in the specified Availability Zone.
	//
	VMIPAssignmentList []*RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0VMIPAssignmentListItems0 `json:"vm_ip_assignment_list"`
}

// Validate validates this recovery plan resources parameters floating IP assignment list items0
func (m *RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAvailabilityZoneURL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVMIPAssignmentList(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0) validateAvailabilityZoneURL(formats strfmt.Registry) error {

	if err := validate.Required("availability_zone_url", "body", m.AvailabilityZoneURL); err != nil {
		return err
	}

	return nil
}

func (m *RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0) validateVMIPAssignmentList(formats strfmt.Registry) error {
	if swag.IsZero(m.VMIPAssignmentList) { // not required
		return nil
	}

	for i := 0; i < len(m.VMIPAssignmentList); i++ {
		if swag.IsZero(m.VMIPAssignmentList[i]) { // not required
			continue
		}

		if m.VMIPAssignmentList[i] != nil {
			if err := m.VMIPAssignmentList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vm_ip_assignment_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("vm_ip_assignment_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this recovery plan resources parameters floating IP assignment list items0 based on the context it is used
func (m *RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateVMIPAssignmentList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0) contextValidateVMIPAssignmentList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.VMIPAssignmentList); i++ {

		if m.VMIPAssignmentList[i] != nil {

			if swag.IsZero(m.VMIPAssignmentList[i]) { // not required
				return nil
			}

			if err := m.VMIPAssignmentList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vm_ip_assignment_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("vm_ip_assignment_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0) UnmarshalBinary(b []byte) error {
	var res RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0VMIPAssignmentListItems0 recovery plan resources parameters floating IP assignment list items0 VM IP assignment list items0
//
// swagger:model RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0VMIPAssignmentListItems0
type RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0VMIPAssignmentListItems0 struct {

	// Configuration for floating IP assignment on failover.
	//
	RecoveryFloatingIPConfig *RecoveryPlanFloatingIPConfig `json:"recovery_floating_ip_config,omitempty"`

	// Configuration for floating IP assignment on test failover.
	//
	TestFloatingIPConfig *RecoveryPlanFloatingIPConfig `json:"test_floating_ip_config,omitempty"`

	// vm nic information
	// Required: true
	VMNicInformation *RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0VMIPAssignmentListItems0VMNicInformation `json:"vm_nic_information"`

	// Reference to the VM entity.
	// Required: true
	VMReference *VMReference `json:"vm_reference"`
}

// Validate validates this recovery plan resources parameters floating IP assignment list items0 VM IP assignment list items0
func (m *RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0VMIPAssignmentListItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateRecoveryFloatingIPConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTestFloatingIPConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVMNicInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVMReference(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0VMIPAssignmentListItems0) validateRecoveryFloatingIPConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.RecoveryFloatingIPConfig) { // not required
		return nil
	}

	if m.RecoveryFloatingIPConfig != nil {
		if err := m.RecoveryFloatingIPConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("recovery_floating_ip_config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("recovery_floating_ip_config")
			}
			return err
		}
	}

	return nil
}

func (m *RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0VMIPAssignmentListItems0) validateTestFloatingIPConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.TestFloatingIPConfig) { // not required
		return nil
	}

	if m.TestFloatingIPConfig != nil {
		if err := m.TestFloatingIPConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("test_floating_ip_config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("test_floating_ip_config")
			}
			return err
		}
	}

	return nil
}

func (m *RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0VMIPAssignmentListItems0) validateVMNicInformation(formats strfmt.Registry) error {

	if err := validate.Required("vm_nic_information", "body", m.VMNicInformation); err != nil {
		return err
	}

	if m.VMNicInformation != nil {
		if err := m.VMNicInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vm_nic_information")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vm_nic_information")
			}
			return err
		}
	}

	return nil
}

func (m *RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0VMIPAssignmentListItems0) validateVMReference(formats strfmt.Registry) error {

	if err := validate.Required("vm_reference", "body", m.VMReference); err != nil {
		return err
	}

	if m.VMReference != nil {
		if err := m.VMReference.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vm_reference")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vm_reference")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this recovery plan resources parameters floating IP assignment list items0 VM IP assignment list items0 based on the context it is used
func (m *RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0VMIPAssignmentListItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateRecoveryFloatingIPConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTestFloatingIPConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVMNicInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVMReference(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0VMIPAssignmentListItems0) contextValidateRecoveryFloatingIPConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.RecoveryFloatingIPConfig != nil {

		if swag.IsZero(m.RecoveryFloatingIPConfig) { // not required
			return nil
		}

		if err := m.RecoveryFloatingIPConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("recovery_floating_ip_config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("recovery_floating_ip_config")
			}
			return err
		}
	}

	return nil
}

func (m *RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0VMIPAssignmentListItems0) contextValidateTestFloatingIPConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.TestFloatingIPConfig != nil {

		if swag.IsZero(m.TestFloatingIPConfig) { // not required
			return nil
		}

		if err := m.TestFloatingIPConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("test_floating_ip_config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("test_floating_ip_config")
			}
			return err
		}
	}

	return nil
}

func (m *RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0VMIPAssignmentListItems0) contextValidateVMNicInformation(ctx context.Context, formats strfmt.Registry) error {

	if m.VMNicInformation != nil {

		if err := m.VMNicInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vm_nic_information")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vm_nic_information")
			}
			return err
		}
	}

	return nil
}

func (m *RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0VMIPAssignmentListItems0) contextValidateVMReference(ctx context.Context, formats strfmt.Registry) error {

	if m.VMReference != nil {

		if err := m.VMReference.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vm_reference")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vm_reference")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0VMIPAssignmentListItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0VMIPAssignmentListItems0) UnmarshalBinary(b []byte) error {
	var res RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0VMIPAssignmentListItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0VMIPAssignmentListItems0VMNicInformation Information about vnic to which floating IP has to be assigned.
//
// swagger:model RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0VMIPAssignmentListItems0VMNicInformation
type RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0VMIPAssignmentListItems0VMNicInformation struct {

	// IP address associated with vnic for which floating IP has to be assigned on failover.
	//
	// Pattern: ^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$
	IP string `json:"ip,omitempty"`

	// Uuid of the vnic of the VM to which floating IP has to be assigned.
	//
	// Required: true
	// Pattern: ^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$
	UUID *string `json:"uuid"`
}

// Validate validates this recovery plan resources parameters floating IP assignment list items0 VM IP assignment list items0 VM nic information
func (m *RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0VMIPAssignmentListItems0VMNicInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIP(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUUID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0VMIPAssignmentListItems0VMNicInformation) validateIP(formats strfmt.Registry) error {
	if swag.IsZero(m.IP) { // not required
		return nil
	}

	if err := validate.Pattern("vm_nic_information"+"."+"ip", "body", m.IP, `^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$`); err != nil {
		return err
	}

	return nil
}

func (m *RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0VMIPAssignmentListItems0VMNicInformation) validateUUID(formats strfmt.Registry) error {

	if err := validate.Required("vm_nic_information"+"."+"uuid", "body", m.UUID); err != nil {
		return err
	}

	if err := validate.Pattern("vm_nic_information"+"."+"uuid", "body", *m.UUID, `^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$`); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this recovery plan resources parameters floating IP assignment list items0 VM IP assignment list items0 VM nic information based on context it is used
func (m *RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0VMIPAssignmentListItems0VMNicInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0VMIPAssignmentListItems0VMNicInformation) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0VMIPAssignmentListItems0VMNicInformation) UnmarshalBinary(b []byte) error {
	var res RecoveryPlanResourcesParametersFloatingIPAssignmentListItems0VMIPAssignmentListItems0VMNicInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// RecoveryPlanResourcesParametersNetworkMappingListItems0 recovery plan resources parameters network mapping list items0
//
// swagger:model RecoveryPlanResourcesParametersNetworkMappingListItems0
type RecoveryPlanResourcesParametersNetworkMappingListItems0 struct {

	// Whether the networks across the Availability Zones in above mapping are stretched.
	//
	AreNetworksStretched bool `json:"are_networks_stretched,omitempty"`

	// Mapping of networks across the Availability Zones.
	//
	AvailabilityZoneNetworkMappingList []*RecoveryPlanResourcesParametersNetworkMappingListItems0AvailabilityZoneNetworkMappingListItems0 `json:"availability_zone_network_mapping_list"`
}

// Validate validates this recovery plan resources parameters network mapping list items0
func (m *RecoveryPlanResourcesParametersNetworkMappingListItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAvailabilityZoneNetworkMappingList(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RecoveryPlanResourcesParametersNetworkMappingListItems0) validateAvailabilityZoneNetworkMappingList(formats strfmt.Registry) error {
	if swag.IsZero(m.AvailabilityZoneNetworkMappingList) { // not required
		return nil
	}

	for i := 0; i < len(m.AvailabilityZoneNetworkMappingList); i++ {
		if swag.IsZero(m.AvailabilityZoneNetworkMappingList[i]) { // not required
			continue
		}

		if m.AvailabilityZoneNetworkMappingList[i] != nil {
			if err := m.AvailabilityZoneNetworkMappingList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("availability_zone_network_mapping_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("availability_zone_network_mapping_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this recovery plan resources parameters network mapping list items0 based on the context it is used
func (m *RecoveryPlanResourcesParametersNetworkMappingListItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAvailabilityZoneNetworkMappingList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RecoveryPlanResourcesParametersNetworkMappingListItems0) contextValidateAvailabilityZoneNetworkMappingList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AvailabilityZoneNetworkMappingList); i++ {

		if m.AvailabilityZoneNetworkMappingList[i] != nil {

			if swag.IsZero(m.AvailabilityZoneNetworkMappingList[i]) { // not required
				return nil
			}

			if err := m.AvailabilityZoneNetworkMappingList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("availability_zone_network_mapping_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("availability_zone_network_mapping_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *RecoveryPlanResourcesParametersNetworkMappingListItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RecoveryPlanResourcesParametersNetworkMappingListItems0) UnmarshalBinary(b []byte) error {
	var res RecoveryPlanResourcesParametersNetworkMappingListItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// RecoveryPlanResourcesParametersNetworkMappingListItems0AvailabilityZoneNetworkMappingListItems0 recovery plan resources parameters network mapping list items0 availability zone network mapping list items0
//
// swagger:model RecoveryPlanResourcesParametersNetworkMappingListItems0AvailabilityZoneNetworkMappingListItems0
type RecoveryPlanResourcesParametersNetworkMappingListItems0AvailabilityZoneNetworkMappingListItems0 struct {

	// URL of the Availability Zone.
	//
	// Required: true
	AvailabilityZoneURL *string `json:"availability_zone_url"`

	// The clusters where the recovery and test networks reside. This is required to specify network mapping across clusters for a Recovery Plan created to handle failover within the same Availability Zone.
	//
	ClusterReferenceList []*ClusterReference `json:"cluster_reference_list"`

	// Static IP configuration for the VMs to be applied post recovery in the recovery network for migrate/ failover action on the Recovery Plan.
	//
	RecoveryIPAssignmentList []*RecoveryPlanVMIPAssignment `json:"recovery_ip_assignment_list"`

	// Network in which VMs will be recovered on migrate/ failover action on the Recovery Plan.
	//
	RecoveryNetwork *RecoveryPlanNetwork `json:"recovery_network,omitempty"`

	// Static IP configuration for the VMs to be applied post recovery in the test network for test failover action on the Recovery Plan.
	//
	TestIPAssignmentList []*RecoveryPlanVMIPAssignment `json:"test_ip_assignment_list"`

	// Network in which VMs will be recovered on test failover action on the Recovery Plan.
	//
	TestNetwork *RecoveryPlanNetwork `json:"test_network,omitempty"`
}

// Validate validates this recovery plan resources parameters network mapping list items0 availability zone network mapping list items0
func (m *RecoveryPlanResourcesParametersNetworkMappingListItems0AvailabilityZoneNetworkMappingListItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAvailabilityZoneURL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClusterReferenceList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecoveryIPAssignmentList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecoveryNetwork(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTestIPAssignmentList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTestNetwork(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RecoveryPlanResourcesParametersNetworkMappingListItems0AvailabilityZoneNetworkMappingListItems0) validateAvailabilityZoneURL(formats strfmt.Registry) error {

	if err := validate.Required("availability_zone_url", "body", m.AvailabilityZoneURL); err != nil {
		return err
	}

	return nil
}

func (m *RecoveryPlanResourcesParametersNetworkMappingListItems0AvailabilityZoneNetworkMappingListItems0) validateClusterReferenceList(formats strfmt.Registry) error {
	if swag.IsZero(m.ClusterReferenceList) { // not required
		return nil
	}

	for i := 0; i < len(m.ClusterReferenceList); i++ {
		if swag.IsZero(m.ClusterReferenceList[i]) { // not required
			continue
		}

		if m.ClusterReferenceList[i] != nil {
			if err := m.ClusterReferenceList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cluster_reference_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("cluster_reference_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RecoveryPlanResourcesParametersNetworkMappingListItems0AvailabilityZoneNetworkMappingListItems0) validateRecoveryIPAssignmentList(formats strfmt.Registry) error {
	if swag.IsZero(m.RecoveryIPAssignmentList) { // not required
		return nil
	}

	for i := 0; i < len(m.RecoveryIPAssignmentList); i++ {
		if swag.IsZero(m.RecoveryIPAssignmentList[i]) { // not required
			continue
		}

		if m.RecoveryIPAssignmentList[i] != nil {
			if err := m.RecoveryIPAssignmentList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("recovery_ip_assignment_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("recovery_ip_assignment_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RecoveryPlanResourcesParametersNetworkMappingListItems0AvailabilityZoneNetworkMappingListItems0) validateRecoveryNetwork(formats strfmt.Registry) error {
	if swag.IsZero(m.RecoveryNetwork) { // not required
		return nil
	}

	if m.RecoveryNetwork != nil {
		if err := m.RecoveryNetwork.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("recovery_network")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("recovery_network")
			}
			return err
		}
	}

	return nil
}

func (m *RecoveryPlanResourcesParametersNetworkMappingListItems0AvailabilityZoneNetworkMappingListItems0) validateTestIPAssignmentList(formats strfmt.Registry) error {
	if swag.IsZero(m.TestIPAssignmentList) { // not required
		return nil
	}

	for i := 0; i < len(m.TestIPAssignmentList); i++ {
		if swag.IsZero(m.TestIPAssignmentList[i]) { // not required
			continue
		}

		if m.TestIPAssignmentList[i] != nil {
			if err := m.TestIPAssignmentList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("test_ip_assignment_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("test_ip_assignment_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RecoveryPlanResourcesParametersNetworkMappingListItems0AvailabilityZoneNetworkMappingListItems0) validateTestNetwork(formats strfmt.Registry) error {
	if swag.IsZero(m.TestNetwork) { // not required
		return nil
	}

	if m.TestNetwork != nil {
		if err := m.TestNetwork.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("test_network")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("test_network")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this recovery plan resources parameters network mapping list items0 availability zone network mapping list items0 based on the context it is used
func (m *RecoveryPlanResourcesParametersNetworkMappingListItems0AvailabilityZoneNetworkMappingListItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateClusterReferenceList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRecoveryIPAssignmentList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRecoveryNetwork(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTestIPAssignmentList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTestNetwork(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RecoveryPlanResourcesParametersNetworkMappingListItems0AvailabilityZoneNetworkMappingListItems0) contextValidateClusterReferenceList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ClusterReferenceList); i++ {

		if m.ClusterReferenceList[i] != nil {

			if swag.IsZero(m.ClusterReferenceList[i]) { // not required
				return nil
			}

			if err := m.ClusterReferenceList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cluster_reference_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("cluster_reference_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RecoveryPlanResourcesParametersNetworkMappingListItems0AvailabilityZoneNetworkMappingListItems0) contextValidateRecoveryIPAssignmentList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.RecoveryIPAssignmentList); i++ {

		if m.RecoveryIPAssignmentList[i] != nil {

			if swag.IsZero(m.RecoveryIPAssignmentList[i]) { // not required
				return nil
			}

			if err := m.RecoveryIPAssignmentList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("recovery_ip_assignment_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("recovery_ip_assignment_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RecoveryPlanResourcesParametersNetworkMappingListItems0AvailabilityZoneNetworkMappingListItems0) contextValidateRecoveryNetwork(ctx context.Context, formats strfmt.Registry) error {

	if m.RecoveryNetwork != nil {

		if swag.IsZero(m.RecoveryNetwork) { // not required
			return nil
		}

		if err := m.RecoveryNetwork.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("recovery_network")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("recovery_network")
			}
			return err
		}
	}

	return nil
}

func (m *RecoveryPlanResourcesParametersNetworkMappingListItems0AvailabilityZoneNetworkMappingListItems0) contextValidateTestIPAssignmentList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.TestIPAssignmentList); i++ {

		if m.TestIPAssignmentList[i] != nil {

			if swag.IsZero(m.TestIPAssignmentList[i]) { // not required
				return nil
			}

			if err := m.TestIPAssignmentList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("test_ip_assignment_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("test_ip_assignment_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RecoveryPlanResourcesParametersNetworkMappingListItems0AvailabilityZoneNetworkMappingListItems0) contextValidateTestNetwork(ctx context.Context, formats strfmt.Registry) error {

	if m.TestNetwork != nil {

		if swag.IsZero(m.TestNetwork) { // not required
			return nil
		}

		if err := m.TestNetwork.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("test_network")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("test_network")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RecoveryPlanResourcesParametersNetworkMappingListItems0AvailabilityZoneNetworkMappingListItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RecoveryPlanResourcesParametersNetworkMappingListItems0AvailabilityZoneNetworkMappingListItems0) UnmarshalBinary(b []byte) error {
	var res RecoveryPlanResourcesParametersNetworkMappingListItems0AvailabilityZoneNetworkMappingListItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
